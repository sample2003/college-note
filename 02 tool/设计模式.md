设计模式分类

创建型模式
结构型模式
行为型模式

# 软件设计原则

提供软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性

开闭原则

对扩展开发，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性号，易于维护和升级。

想要达到这样的效果，我们需要使用接口和抽象类。
因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展。

# 观察者模式

## 概述

又被称为发布-订阅(Publish/Subscribe)模式,它定义了一种一对多的依赖关系,让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时,会通知所有的观察者对象,使他们能够自动更新自己。

## 结构

在观察者模式中有如下角色:
Subject：抽象主题(抽象被观察者),抽象主题角色把所有观察者对象保存在一个集合里,每个主题都可以有任意数量的观察者,抽象主题提供一个接口,可以增加和删除观察者对象。
ConcreteSubiect：具体主题(具体被观察者),该角色将有关状态存入具体观察者对象,在具体主题的内部状态发生改变时,给所有注册过的观察者发送通知。
Observer：抽象观察者,是观察者的抽象类,它定义了一个更新接口,使得在得到主题更改通知时更新自己。
ConcrereObservert：具体观察者,实现抽象观察者定义的更新接口,以便在得到主题更改通知时更新自身的状态。

优点
降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系
被观察者发送通知，所有注册的观察者都会收到信息

缺点
若观察者过多，那么所有的观察者收到被观察者发送的通知会耗时
如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用

使用场景
对象之间存在一对多关系，一个对象的状态发送改变会影响其他对象
当一个抽象模型有两个方面，其中一个方面依赖另一个方面

# 适配器模式

## 概述

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
适配器模式分为类适配器和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少

## 结构

适配器模式(Adapter)包含以下主要角色
目标(Target)接口：当前系统业务所期待的接口，它可以是抽象类或接口
适配者(Adaptee)类：当前系统业务的接口，它是被访问和适配的现存组件库中的组件接口。
适配器(Adapter)类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

## 类适配器模式

实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。

类适配器模式违背了合成规范原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。

## 对象适配器模式

实现方式：对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。

还有一个适配器模式是接口适配器模式。当不希望实现一个接口中的所有方法时，可以创建一个抽象类Adapter，实现所有方法，而此时我们只需要继承该抽象类即可。

应用场景

以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

# 单例模式

## 1. 饿汉式

类加载就会导致该单例对象被创建。

**饿汉式-静态成员变量**

该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类对象instance。instane对象是随着类的加载而创建的。如果该对象足够大，且一直没有使用会造成内存的浪费。

**饿汉式-静态代码块**

该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是随着类的加载而创建的。如果该对象足够大，且一直没有使用会造成内存的浪费。

## 2. 懒汉式

类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建。

**懒汉式-线程不安全**

从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题

添加了synchronized实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。其实在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。
```java
public class Singleton{
	...
	public stati synchronized Singleton getInstance(){
		...
	}
}
```

**懒汉式-双重检查锁**

对于getInstance()方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必要让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式。

双重检查锁模式是一种非常好的单例实现模式,解决了单例、性能、线程安全问题,上面的双重检测锁模式看上去完美无缺,其实存在问题,在多线程的情况下,可能会出现空指针问题,出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。

要解决双重检查锁模式带来空指针异常的问题,只需要使用volatile关键字,volatile关键字可以保证可见性和有序性。
```java
public class Singleton{
	...
	private static volatile Singleton instance;
	...
}
```

**懒汉式-静态内部类**

静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 `static` 修饰，保证只被实例化一次，并且严格保证实例化顺序。

第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder
并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。

静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。